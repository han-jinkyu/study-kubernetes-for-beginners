# 1. 파드 네트워킹

## 1.1 도커 컨테이너의 네트워킹 이해하기

- 도커 브리지 타입 네트워크는 호스트 안에 `docker0`라는 브리지를 추가해 컨테이너와 호스트 사이를 연결한다.
- 네트워크 네임스페이스가 존재하며, 안에는 별도의 ARP, 라우팅, iptables가 있다.
- `docker0`와 `NAT`을 포함하는 네임스페이스는 **호스트 네트워크 네임스페이스 또는 디폴트 네트워크 네임스페이스**라 한다.
    - 호스트의 기본 네트워크는 여기서 생성하고 관리한다.
- 컨테이너가 생성할 때마다 **컨테이너 네트워크 네임스페이스**가 생성되며, 별도의 네트워크를 사용할 수 있다.
- 네트워크 네임스페이스는 서로 연결되기 전엔 독립적으로 동작한다.
- 도커는 각 네트워크 네임스페이스를 서로 연결하기 위해 `veth`(virtual ethernet)라는 장치를 사용한다.
- `veth`는 한쪽 끝은 컨테이너, 다른 한 끝은 호스트의 브리지(기본은 `docker0` 브리지)에 연결해서 호스트 네임스페이스와 컨테이너 네트워크 사이를 통신한다.
- 도커 브리지 타입 네트워크에선 별다른 설정이 없으면 `172.17.0.1/24` 사이의 IP를 사용한다.
- 도커 컨테이너 네트워킹(도커 컨테이너와 호스트를 연결하는 네트워킹)엔 다음과 같은 타입이 있다.
    - 브리지 타입: 호스트에 브리지를 만들고 컨테이너와 호스트는 veth를 이용해서 연결한다.
    - 오버레이 타입: 여러 호스트가 있을 때 각 호스트에 있는 컨테이너 네트워크를 오버레이 네트워크(VXLAN)로 연결한다. 도커 스웜에서 기본 네트워크로 사용.
    - 맥브이랜 타입: 맥브이랜이라는 이더넷 장치 하나에서 여러 가상 MAC 주소를 할당하는 기술을 통해, 컨테이너에 MAC 주소와 IP 주소를 할당한다.
    - 호스트 타입: 컨테이너 네트워크 네임스페이스 대신 호스트의 네트워크 네임스페이스를 직접 사용한다.
    - 링크 타입: 컨테이너별로 네트워크 네임스페이스를 만들지 않고, 이미 생성되어 있는 네트워크 네임스페이스에 컨테이너를 연결한다. 쿠퍼네티스 파드 네트워크의 기본이다.

```zsh
# 타입을 확인
$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
92b52baaee4d   bridge    bridge    local
b3f872fc515b   host      host      local
2422eae978ed   none      null      local

# 네트워크 타입별 자세한 설정 확인
$ docker network inspect bridge
[
    {
        // ...
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",      # [1]
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        // ...
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",   # [2]
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",    # [3]
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]
```

- 위 내용은 다음과 같다.
    - `[1]`: 컨테이너에 할당될 서브넷 IP다. IP 주소를 바꾸려면 `/etc/docker/daemon.json`에서 해당 부분을 수정한다.
    - `[2]`: 호스트 네트워크 네임스페이스에서 172.17.0.0/16 사이의 서브넷 IP 주소가 설정된 네트워크에 네트워크 주소 변환(NAT)을 적용한다는 설정이다.
    - `[3]`: 컨테이너 네트워크 네임스페이스의 veth와 호스트의 네트워크 네임스페이스를 연결할 브리지 이름을 설정한다.

```zsh
# 실제로 네트워크 네임스페이스를 서로 연결했는지 확인한다
# 도커 컨테이너 하나 실행
$ docker run -it arisu1000/simple-container-app:latest

# 접속창 하나를 더 띄워 컨테이너 ID 확인
$ docker ps | grep simple-container-app
c5ff39f37596   arisu1000/simple-container-app:latest   "./simple-container-…"   54 seconds ago   Up 53 seconds             upbeat_noyce

# 해당 네임스페이스의 모든 네트워크 인터페이스를 확인
$ docker exec -it c5ff39f37596 ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: tunl0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: ip6tnl0@NONE: <NOARP> mtu 1452 qdisc noop state DOWN qlen 1000
    link/tunnel6 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 brd 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
44: eth0@if45: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
```

- `eth0@if45`는 해당 veth가 `if45`와 연결되었다는 뜻이다.
- `if45`는 호스트의 네트워크 네임스페이스에 있을 것이다.
- 양 끝을 서로 다른 네트워크 네임스페이스 또는 장치에 연결할 수 있으므로 베스쌍(veth pair)라고 부른다.

-----
[HOME](./index.md)
